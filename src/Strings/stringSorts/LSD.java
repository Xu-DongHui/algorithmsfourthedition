package Strings.stringSorts;

/*
 * 1.字符串排序的两种方法：
 * （1）低位优先：从右向左检查键中的字符。可以将字符串看成一个256进制的数字，从右往左检查字符串等价于先检查数字的最低位。这种方法适用于字符串的长度都相同的排序。
 * （2）高位优先：从左向右检查键中的字符。不一定要检查所有的输入就能完成排序。
 * 2.键索引计数：
 * （1）频率统计：count数组计算每个键出现的频率
 * （2）将频率转换为索引：使用count数组计算每个键在排序中的起始索引位置。任意给定键的起始索引为所有较小的键所对应的出现频率之和。
 * （3）数据分类：每个键在aux[]中的位置由对应的count[]值决定，在插入一个键后，将对应的count[]值加1，保证count[r]总是下一个键为r的元素在aux[]中的索引位置。
 * （4）回写：将排序结果复制回原数组
 * 3.键索引计数法维护了等键元素的相对顺序，是一个常数级别的排序方法。
 * 4.低位优先的字符串排序：字符串的长度均为W，从右向左以每个位置的字符作为键，用键索引计数法将字符串排序W遍。
 */

public class LSD {
//	从右往左检查，检查过的键是有序的
	public static void sort(String[] a, int W) {
		int N = a.length;
//		可以将字符串看做是一个256进制的数字，即共有256个不同的字符。
		int R = 256;
		String[] aux = new String[N];
//		对第d个字符进行键索引计数
		for(int d = W - 1; d >= 0; d--) {
//			统计每个键出现的频率：键r对应的是count[r+1]
			int[] count = new int[R + 1];
			for(int i = 0; i < N; i++)
				count[a[i].charAt(d) + 1]++;
			
//			键为0,1,2,3,...,R-1
//			将每个键的频率转换为每个键在排序中的起始索引：键r对应的起始索引是count[r]
//			count[0]=0，对于键r，正好只叠加了r之前键的个数，作为r的起始索引
			for(int r = 0; r < R; r++) {
				count[r + 1] += count[r];
			}
			
//			对于n个字符串分类：根据每个字符串的键的起始索引进行插入，并更新该键的下一个插入索引
			for(int i = 0; i < N; i++) 
				aux[count[a[i].charAt(d)]++] = a[i];
			
//			更新原数组
			for(int i = 0; i < N; i++)
				a[i] = aux[i];
		}
	}
}
